<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>map和set</title>
    <link href="/2022/08/19/map%E5%92%8Cset/"/>
    <url>/2022/08/19/map%E5%92%8Cset/</url>
    
    <content type="html"><![CDATA[<p>map和set</p><p>关联容器支持高效的关键字查找和访问。两个主要的关联容器是map和set，map中的元素是键值对。</p><table><thead><tr><th>有序</th><th>介绍</th></tr></thead><tbody><tr><td>map</td><td>保存键值对</td></tr><tr><td>set</td><td>只保存关键字</td></tr><tr><td>multimap</td><td>关键字可以重复出现</td></tr><tr><td>multiset</td><td>关键字可以重复出现</td></tr><tr><td><strong>无序</strong></td><td></td></tr><tr><td>unordered_map</td><td>用哈希函数组织的map</td></tr><tr><td>unordered_set</td><td>用哈希函数组织的set</td></tr><tr><td>unordered_multimap</td><td>用哈希函数组织的map:关键字可以重复出现</td></tr></tbody></table><p>分别给出最适合使用<code>list</code>、<code>vector</code>、<code>deque</code>、<code>map</code>以及<code>set</code>的例子。</p><ul><li><p><code>list</code>：双向链表，适合频繁插入删除元素的场景。</p></li><li><p><code>vector</code>：适合频繁访问元素的场景。</p></li><li><p><code>deque</code>：双端队列，适合频繁在头尾插入删除元素的场景。</p></li><li><p><code>map</code>：字典。</p></li><li><p><code>set</code>：适合有序不重复的元素的场景。</p></li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map</code>的特性是所有元素都会根据键值自动排序，<code>map</code>的所有元素都是<code>pair</code>，同时拥有键值和实值。不允许两个相同的元素具有相同的键值。</p><h4 id="可以通过map的迭代器改变元素内容吗？"><a href="#可以通过map的迭代器改变元素内容吗？" class="headerlink" title="可以通过map的迭代器改变元素内容吗？"></a>可以通过<code>map</code>的迭代器改变元素内容吗？</h4><p>如果想要修改元素的键值，是不可以的。因为键值关乎到<code>map</code>元素的排列规则。但是如果想要修改实值是可以的，因为实值并不影响元素的排列规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++C++">map&lt;int,string&gt; mymap&#123;&#123;1,&quot;hello&quot;&#125;,&#123;2,&quot;world&quot;&#125;,&#123;3,&quot;use&quot;&#125;,&#123;4,&quot;C++&quot;&#125;&#125;;<br>auto it = mymap.begin();<br><br>while(it!=mymap.end())&#123;<br>cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;<br>++it;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>map</code>的一些操作和<code>list</code>相似，行元素新增操作或者删除操作时，操作之前的所有的迭代器操作完成之后依然都有效。</p><h3 id="map的定义"><a href="#map的定义" class="headerlink" title="map的定义"></a>map的定义</h3><p>定义map时必须既指明关键字类型又指明值类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;string,<span class="hljs-type">size_t</span>&gt; word_count;<span class="hljs-comment">//空容器</span><br>map&lt;string,string&gt; authors=&#123;&#123;<span class="hljs-string">&quot;Joyce&quot;</span>,<span class="hljs-string">&quot;James&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;Austen&quot;</span>,<span class="hljs-string">&quot;Jane&quot;</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><h3 id="map的查找和遍历"><a href="#map的查找和遍历" class="headerlink" title="map的查找和遍历"></a>map的查找和遍历</h3><ul><li>使用迭代器进行遍历</li><li>数组形式，index为key</li><li>find查找指定的key</li></ul><h4 id="find和count"><a href="#find和count" class="headerlink" title="find和count"></a>find和count</h4><p>使用<em>find</em>和<em>count</em>函数，可以通过<em>find</em>查找指定的关键字是否出现，count函数返回的是一个容器中，某一元素出现的次数，对于map，即返回key出现的次数，但是map中的key是不允许重复出现的，故count函数返回值只能是1（存在）或0（不存在）。</p><p>使用find，返回的是一个迭代器，若容器中不存在该关键字则返回<em>map.end()</em><br>如：要找到某一个key的value值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mymap;<br><span class="hljs-keyword">if</span>(mymap.<span class="hljs-built_in">find</span>(key)!=mymap.<span class="hljs-built_in">end</span>())&#123;<br>    cout&lt;&lt;mymap.<span class="hljs-built_in">find</span>(key)-&gt;second&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数组形式"><a href="#数组形式" class="headerlink" title="数组形式"></a>数组形式</h4><p><em>map</em>中可以使用下标运算符和对应的*at( )*函数，但是set类型不支持下标，因为set中没有与关键字相关联的“值”，元素本身就是关键字。map下标运算符接收一个索引，获取与此关键字相关联的值，如果关键字并不在map中，则为它创建一个元素插入到map中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;string,<span class="hljs-type">sizet_t</span>&gt; word_count;<span class="hljs-comment">//空map</span><br>word_count[<span class="hljs-string">&quot;Anna&quot;</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//在word_count中搜索关键字为Anna的元素，未找到，则进行插入操作。</span><br>word.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;Anna&quot;</span>);<span class="hljs-comment">//访问关键字为Anna的值</span><br></code></pre></td></tr></table></figure><h3 id="map中插入元素"><a href="#map中插入元素" class="headerlink" title="map中插入元素"></a>map中插入元素</h3><p>对map中进行insert操作时，元素类型必须是pair类型，因此在insert的参数列表中创建一个pair。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">word_count.<span class="hljs-built_in">insert</span>(&#123;word,<span class="hljs-number">1</span>&#125;);<br>word_count.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(word,<span class="hljs-number">1</span>));<br>word_count.<span class="hljs-built_in">insert</span>(map&lt;string,<span class="hljs-type">size_t</span>&gt;::<span class="hljs-built_in">value_type</span>(word,<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h3 id="map的删除"><a href="#map的删除" class="headerlink" title="map的删除"></a>map的删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">iterator erase（iterator it);<span class="hljs-comment">//通过一个条目对象删除</span><br>iterator erase（iterator first，iterator last）<span class="hljs-comment">//删除一个范围</span><br><span class="hljs-function">size_type <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp;key)</span></span>;<span class="hljs-comment">//通过关键字删除</span><br></code></pre></td></tr></table></figure><h2 id="map和unordered-map区别"><a href="#map和unordered-map区别" class="headerlink" title="map和unordered_map区别"></a>map和unordered_map区别</h2><h3 id="内部实现机理不同"><a href="#内部实现机理不同" class="headerlink" title="内部实现机理不同"></a>内部实现机理不同</h3><p><strong>map：</strong>内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部都是有序的红黑树，每一个节点都代表着map的一个元素。</p><p><strong>unordered_map：</strong>内部实现了一个哈希表（把关键值映射到hash表中的一个位置来访问，查找时间复杂度可以达到O(1)，在海量数据处理中有广泛应用）</p><p><strong>map</strong>的<code>key</code>可以是任何类型，但是unordered_map的<code>key</code><strong>只能是C++中定义的关键字类型</strong></p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p><code>set</code>的特性是所有元素都会根据键值自动排序，<code>set</code>中元素的键值就是实值，实值就是键值，<code>set</code>不允许两个元素具有相同的键值。</p><h4 id="是否可以通过迭代器来改变set元素值？"><a href="#是否可以通过迭代器来改变set元素值？" class="headerlink" title="是否可以通过迭代器来改变set元素值？"></a>是否可以通过迭代器来改变<code>set</code>元素值？</h4><p>不可以。</p><p>因为<code>set</code>的元素值就是键值，关系到set元素的排列规则，如果任意改变set的元素值会严重破坏<code>set</code>组织。从<code>set</code>的源码中可以看到，``set<T>::iterator<code>被定义为底层红黑树的</code>const_iterator`。</p><p><code>set</code>具有和<code>list</code>相同的某些性质，当对<code>set</code>进行元素新增操作或者删除操作时，操作之前的所有的迭代器操作完成之后依然都有效。</p><h3 id="与set声明和常见API"><a href="#与set声明和常见API" class="headerlink" title="与set声明和常见API"></a>与set声明和常见API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; myvec=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;<br>set&lt;<span class="hljs-type">int</span>&gt; myset;<span class="hljs-comment">//声明</span><br>myset.<span class="hljs-built_in">insert</span>(myvec.<span class="hljs-built_in">cbegin</span>(),myvec.<span class="hljs-built_in">cend</span>());<span class="hljs-comment">//新增4个元素</span><br>myset.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;)<span class="hljs-comment">//新增4个元素</span><br>myset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//新增一个元素</span><br><br>myset.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//set中元素的个数</span><br>myset.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//删除set中的所有元素</span><br>myset.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//判断set是否为空</span><br>myset.<span class="hljs-built_in">max_size</span>();<span class="hljs-comment">//返回容器中可能包含的元素的最大个数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图解HTTP笔记</title>
    <link href="/2022/08/12/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/12/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>图解HTTP阅读笔记</p><h2 id="OSI七层和TCP-IP四层模型"><a href="#OSI七层和TCP-IP四层模型" class="headerlink" title="OSI七层和TCP/IP四层模型"></a>OSI七层和TCP/IP四层模型</h2><p><img src="/images/%E6%88%AA%E5%9B%BE.png"></p><h2 id="TCP-IP中数据发送过程"><a href="#TCP-IP中数据发送过程" class="headerlink" title="TCP/IP中数据发送过程"></a>TCP/IP中数据发送过程</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B.png"></p><h2 id="HTTP协议关系密切的三个协议"><a href="#HTTP协议关系密切的三个协议" class="headerlink" title="HTTP协议关系密切的三个协议"></a>HTTP协议关系密切的三个协议</h2><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议位于网络层，它的主要作用就是将各种数据包传送给对方，其需要两个重要的地址，一个是IP地址，另外一个是MAC地址</p><p>IP在传送各种数据包的时候，并不是直接发送到目标主机上，而是通过路由中转，类似于现实中的快递中转策略一样。</p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP协议在传输层，提供字节流服务。它将上层的HTTP中的数据切割为一个个的报文段来方便传输，并且提供的是可靠传输。</p><p>在TCP建立连接之前，需要进行三次握手，三次握手过程中有一个非常重要的标志即SYN和ACK</p><p><img src="/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><h3 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h3><p>DNS是域名解析协议，负责将域名解析为IP地址。</p><h3 id="各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）"><a href="#各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）" class="headerlink" title="各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）"></a>各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）</h3><p><img src="/images/URL%E8%BE%93%E5%85%A5%E4%B9%8B%E5%90%8E%E7%9A%84%E8%BF%87%E7%A8%8B.png"></p><h2 id="HTTP协议结构基础"><a href="#HTTP协议结构基础" class="headerlink" title="HTTP协议结构基础"></a>HTTP协议结构基础</h2><p>HTTP是一种请求响应式协议，通信过程必须要有一个客户端和一个服务端，通过客户端发起请求，服务端进行响应。传输过程对消息内容进行压缩编码和分块传输。</p><p><img src="/images/%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94.png"></p><h3 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h3><p><img src="/images/%E8%AF%B7%E6%B1%82%E6%8A%A5%E5%A4%B4.png"></p><p><img src="/images/%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8.png"></p><p>起始行开头的GET和POST方法表示请求访问服务器的类型，叫方法。GET获取服务器的资源，POST向服务器发送信息</p><p><em>GET和POST方法都是安全和幂等的吗？</em></p><ul><li><p><em>安全：在HTTP协议中，安全是指请求的方法不会破坏服务器上的资源</em></p></li><li><p><em>幂等：多次执行相同的操作结果都是相同的</em></p></li><li><p><em>GET方法是安全且幂等的，因为其是只读操作，POST方法是不安全且不幂等的</em></p></li></ul><p>紧接着的URI表示请求访问的资源对象</p><p>HOST是服务器域名，因为同一个服务器上使用虚拟主机的方式可能会部署多个域名，但是经过DNS解析之后，这些域名都指向同一个IP地址，因此用HOST来区分</p><p>HTTP/1.1，指明HTTP版本号</p><p>Connection字段：用来管理持久连接，HTTP/1.1版本默认都是持久连接，旧版本不是，需要指定该字段为Keep-alive，如果想要断开连接，指定为close</p><p>Accept字段：表明客户端可以接受的内容格式</p><p>Accept-Encoding字段：客户端支持的内容编码</p><p>Accept-Language字段：客户端能够处理的语言类型</p><h3 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h3><p><img src="/images/%E5%93%8D%E5%BA%94%E6%8A%A5%E5%A4%B4.png"></p><p>HTTP/1.1表示服务器对应的HTTP版本</p><p>200 OK 是请求处理结果的状态码</p><h3 id="HTTP的无状态属性"><a href="#HTTP的无状态属性" class="headerlink" title="HTTP的无状态属性"></a>HTTP的无状态属性</h3><p>http协议是无状态协议，不对之前的请求和响应进行保存。比如登录淘宝网址，如果不对登录的情况进行保存，每次跳转都要进行重新登录，这是非常麻烦的，但是如果让服务器记录每个客户端的状态，也不现实，不符合HTTP轻量化设计的初衷</p><p><strong>引用Cookie技术来保存状态，在请求和响应报文中写入Cookie信息</strong></p><p>初次客户端向服务端发送请求报文，服务端会在响应报文中添加一个Set-Cookie字段，设置Cookie值；客户端收到响应后，会保存这个Cookie值，并在下次请求报文中加上这个Cookie值，这样服务端就可以根据Cookie值来判断请求消息来自于那个客户端。对比服务器上的记录，得到之前的状态信息</p><p><img src="/images/Cookie.png"></p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>在HTTP协议的最初版本中每进行一次HTTP的通信，就要进行一次的TCP连接和断开，增加通信量的开销</p><p>HTTP/1.1和部分HTTP/1.0支持持久连接，也称为Keep-alive方法，即一次TCP连接，多次进行HTTP的请求和响应，直到一端提出明确的断连</p><p><img src="/images/%E6%8C%81%E4%B9%85%E5%8C%96.png"></p><h3 id="管线化技术"><a href="#管线化技术" class="headerlink" title="管线化技术"></a>管线化技术</h3><p>管线化技术是建立在持久连接基础之上的，以往客户端都是发送一个请求然后等待服务器响应，然后再发送下一个请求。管线化技术中，客户端可以连续发送多个请求而不等待服务端的响应，服务端在收到多个请求后，挨个发送响应</p><p><img src="/images/%E7%AE%A1%E7%BA%BF%E5%8C%96.png"></p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>服务器通过状态码来表示对客户端请求响应的处理结果，常见的状态码主要有五类，如下图所示：</p><p><img src="/images/%E7%8A%B6%E6%80%81%E7%A0%81.png"></p><h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3><ul><li>200  OK：客户端请求被正常处理</li><li>204  No Content：服务器正常处理请求，但是没有内容返回</li></ul><h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3><ul><li>301  Moved Permanently：表示客户端请求的资源已经被分配给新的URI，应该使用新的URI进行访问</li><li>302  FOUND：资源临时被分到新的URI去了</li></ul><h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3><ul><li>400  Bad Request：表示请求报文中有错误</li><li>401  Unauthorized：表名请求没有通过HTTP认证</li><li>403  Forbidden：服务器拒绝客户端对请求资源的访问</li><li>404  Not Found：服务器上没有请求访问的资源</li></ul><h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3><ul><li>500  Internal Server Error：服务器处理请求时发生错误</li><li>503  Service Unavailable：表明服务器当前可能停机维护，不能处理请求</li></ul><h3 id="HTTP的优点和缺点"><a href="#HTTP的优点和缺点" class="headerlink" title="HTTP的优点和缺点"></a>HTTP的优点和缺点</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>简单：报文格式就是Header+Body，头部信息也是简单的key-value形式</li><li>灵活和易扩展：协议中的各种请求方法、URI/URL、状态码、头字段等各个组成部分，允许开发人员自定义和扩充</li><li>应用广发和跨平台</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法验证报文的完整性，所以有可能遭遇篡改</li><li>无状态传输</li></ul><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTP协议是直接和TCP进行通信，而HTTPS则是HTTP先和SSL进行通信，再由SSL和TCP进行通信。简单来说，HTTPS就是披着SSL外衣的HTTP通信   </p><p>TLS是在SSL为原型开发的协议，有时统一将它们称为SSL </p><p><img src="/images/HTTPS%E5%92%8CHTTP.png"></p><p>使用了SSL，HTTP就有了加密、证书和完整性保护的功能了</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密使用同一个密钥的方式叫做对称加密，在发送加密内容时也必须将密钥发送给对方，这样一旦密钥被劫持就可以对加密内容进行解密。</p><p>SSL使用就是这种加密方式</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密具有两把密钥，公钥可以随意发送，但是私钥只有自己知道。</p><p>发送密文的一方，使用对方发送过来的公钥进行加密内容，对方在收到密文之后，使用自己的私钥进行解密。</p><h3 id="HTTPS使用混合加密的方式"><a href="#HTTPS使用混合加密的方式" class="headerlink" title="HTTPS使用混合加密的方式"></a>HTTPS使用混合加密的方式</h3><p>非对称加密虽然可以确保信息不会被窃听的风险，但是非对称加密在对内容加密的时候，处理速度非常的慢，没有对称加密那样快，所以先使用非对称加密来加密对称加密的密钥，交换密钥成功之后，再使用对称加密的方式来进行通信。  </p><p><img src="/images/%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png"></p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>为了验证公开密钥是安全的，因此客户端和服务端会向数字认证证书机构CA来来申请数字证书签名</p><h3 id="HTTPS的安全通信过程"><a href="#HTTPS的安全通信过程" class="headerlink" title="HTTPS的安全通信过程"></a>HTTPS的安全通信过程</h3><p><img src="/images/HTTPS%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png"></p><ol><li>客户端通过发送ClientHELLO报文开始SSL通信，包括客户端支持的SSL版本，所使用的加密组件（加密算法和密钥长度）</li><li>服务器收到后，以SEVERHELLO作为回应，同样包含SSL版本和加密组件（和客户端相同）</li><li>服务器向客户端发送公开密钥证书</li><li>服务器发送SeverHelloDone，表示最初的SSL握手协商结束</li><li>客户端向服务器发送Pre-master secret随机密码串，随机密码串已经使用公开密钥进行加密</li><li>客户端继续向服务端发送报文，表示之后的内容都会使用随机密码串Pre-master secret进行加密</li><li>客户端发送结束报文，这个报文包含至今全部报文的校验值，握手协商是否已经成功，要以服务器是否能够对本次的内容进行成功解密</li><li>服务器同样发送ChangeCiperSpec报文，表明已经知道使用Pre-master对内容进行加密</li><li>服务器发送Finished报文，至此SSL连接已经建立完成，后续的通信都会受到SSL的保护</li><li>客户端向服务器发起请求</li><li>服务端向客户端发起响应</li><li>客户端发起断开连接请求</li></ol><p>在之上的流程中，应用层发送数据时会附加一个MAC（message Authentication Code）的报文摘要，能够用来验证报文是否遭受篡改，保护报文的完整性</p><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ul><li>HTTP是明文传输，HTTPS是加密传输、</li><li>HTTP在TCP三次握手之后，就可以进行内容传输，HTTPS还要进行SSL/TLS四次握手</li><li>HTTP的端口号是80，HTTPS是443</li><li>HTTPS需要向CA申请数字证书，来证明服务器的身份是可信的</li></ul><h2 id="HTTP的缺陷和改进"><a href="#HTTP的缺陷和改进" class="headerlink" title="HTTP的缺陷和改进"></a>HTTP的缺陷和改进</h2><h3 id="HTTP-1-1对HTTP-1-0的改进"><a href="#HTTP-1-1对HTTP-1-0的改进" class="headerlink" title="HTTP/1.1对HTTP/1.0的改进"></a>HTTP/1.1对HTTP/1.0的改进</h3><ul><li>使用TCP长连接</li><li>支持管道传输</li></ul><p>缺陷</p><ul><li>请求只能从客户端进行发送，客户端不能接受除了响应之外的任何指令</li><li>请求/响应的首部未经压缩就发送，首部信息越多，延迟就会越大</li><li>发送冗长的首部，每次都是发送相同的首部造成很大的浪费</li><li>按照请求的顺序对其进行响应，如果之前的某个请求没有响应，后续的就会堵塞，这就是对头堵塞</li></ul><h3 id="HTTP2对HTTP-1-1的改进"><a href="#HTTP2对HTTP-1-1的改进" class="headerlink" title="HTTP2对HTTP/1.1的改进"></a>HTTP2对HTTP/1.1的改进</h3><p>HTTP2是基于HTTPS的，所以其也是加密传输，能够保证数据传输的安全性</p><ul><li>服务器推送：在HTTP2中服务器也可以主动向客户端推送消息，不再是完全传统的请求相应式工作模式</li><li>头部压缩：如果客户端同时发送多个请求，这些请求的头部相似或者完全一样，协议就会消除这些重复的部分</li><li>多路复用：HTTP2可以并发多个请求和响应，不用按顺序对请求进行响应，避免了对头堵塞的问题</li><li>二进制格式：在HTTP2中数据不再是纯文本的格式，而全面是用二进制编码，报文首部变为头信息帧，报文主体变为数据帧，这样增加了数据传输的效率</li></ul><h3 id="HTTP3对HTTP2的改进"><a href="#HTTP3对HTTP2的改进" class="headerlink" title="HTTP3对HTTP2的改进"></a>HTTP3对HTTP2的改进</h3><p>HTTP2中多个请求复用一个TCP连接，底层TCP协议并不清楚有多少个请求，一旦发生丢包问题，就会触发TCP的重传机制，这样一个TCP连接中的所有HTTP请求都会等待这个被丢的包重传回来，因此HTTP3将下层的TCP协议变为了UDP协议</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/08/11/hello-world/"/>
    <url>/2022/08/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
