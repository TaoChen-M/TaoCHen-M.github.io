<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/11/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    <url>/2022/08/11/%E5%85%B3%E4%BA%8E%E6%88%91/</url>
    
    <content type="html"><![CDATA[<p>title: 欢迎来了解我</p><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C中字符串</title>
    <link href="/2021/10/03/C%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/10/03/C%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="C中的字符串"><a href="#C中的字符串" class="headerlink" title="C中的字符串"></a>C中的字符串</h1><p>C中没有显示的字符串变量，使用字符串指针或者字符串数组的形式</p><h2 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h2><p><code>strlen</code>函数，返回字符串中的字符个数，返回值类型是<code>size_t</code>，如果使用<code>strlen</code>比较两个字符串的长度，不要使用相减的方式，<code>size_t</code>相减的结果是一直大于0的</p><h2 id="复制字符串"><a href="#复制字符串" class="headerlink" title="复制字符串"></a>复制字符串</h2><p><code>strcpy(char *dst, const char *src)</code>，如果源字符串的长度小于目标字符串的长度，复制过来的时候源字符串的<code>\0</code>也会被复制过来，那么在目标<code>dst</code>中<code>\0</code>之后的内容将会被有效的删除。</p><p>如果源字符串的长度大于目标字符串的长度，<code>strcpy</code>函数会侵占数组后面的内存空间，可能会导致原先存在那里的变量的丢失。</p><h2 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h2><p><code>char strcat(char *dst,const char * src)</code>，将一个字符串连接到目标字符串的后面，目标字符串可以是空字符串。</p><h2 id="字符串比较函数"><a href="#字符串比较函数" class="headerlink" title="字符串比较函数"></a>字符串比较函数</h2><p><code>int strcmp(char const *s1, char const *s2)</code>，按照字典序进行比较，如果<code>s1&lt;s2</code>，会返回一个负值，相等是0，大于返回正值。</p><h2 id="字符判定操作"><a href="#字符判定操作" class="headerlink" title="字符判定操作"></a>字符判定操作</h2><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>isspace()</code></td><td align="center">空格</td></tr><tr><td align="center"><code>isdigit()</code></td><td align="center">数字</td></tr><tr><td align="center"><code>isxdigit()</code></td><td align="center">十六进制数字</td></tr><tr><td align="center"><code>islower()</code></td><td align="center">小写字母</td></tr><tr><td align="center"><code>isupper()</code></td><td align="center">大写字母</td></tr><tr><td align="center"><code>isalpha()</code></td><td align="center">字母</td></tr><tr><td align="center"><code>isalnum()</code></td><td align="center">字母或者数字</td></tr></tbody></table><h2 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h2><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>int tolower(int ch)</code></td><td align="center">转为小写</td></tr><tr><td align="center"><code>int toupper(int ch)</code></td><td align="center">转为大写</td></tr></tbody></table><h2 id="内存操作函数"><a href="#内存操作函数" class="headerlink" title="内存操作函数"></a>内存操作函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *dst,<span class="hljs-type">void</span> <span class="hljs-type">const</span> *src,<span class="hljs-type">size_t</span> length)</span></span>;<span class="hljs-comment">//内存拷贝</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-type">void</span> *a,<span class="hljs-type">int</span> ch,<span class="hljs-type">size_t</span> length)</span></span>;<span class="hljs-comment">//内存赋值，一般都是赋值为char，int型也可以但是只能是0或者-1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组指针和指针数组</title>
    <link href="/2021/10/03/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/"/>
    <url>/2021/10/03/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h1><p>优先级顺序（）&gt;[ ]&gt;*</p><ul><li>数组指针：就是数组的指针，形式是<code>char (*p)[]</code></li><li>指针数组：指针的数组，数组中的元素是指针，形式是<code>char *p[]</code></li></ul><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> *arr[<span class="hljs-number">4</span>]=&#123;<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;new&quot;</span>,<span class="hljs-string">&quot;boy&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><p>指针数组中的每个元素都是指针，因为<code>[]</code>的优先级是大于<code>*</code>的，数组arr作为一个局部变量存储在栈区，而对于<code>“hello”</code>这些数值他们是常量，存储在静态存储区，使用一个指针指向这些字符串，<code>arr</code>中保存的就是这些指针</p><h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">char</span> (*p)[<span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p><code>p</code>是一个指针，指向一个<code>char [4]</code>的数组，数组每个元素是<code>char</code>类型的</p><p>和<code>char a[4]</code>的区别在于<code>a</code>是一个长度为4的字符数组，<code>p</code>是一个<code>char [4]</code>类型的，<code>a</code>是数组首元素的地址，<code>p</code>是数组首地址，两者的地址虽然一样，但是概念却是不同的。将<code>a+1</code>或的是数组<code>a</code>中第二个元素的地址，而<code>p+1</code>则会将<code>p</code>指向数组的末尾结束，那么如何将<code>p</code>指向数组<code>a</code>呢，使用取地址的方式<code>p=&amp;a</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB调试过程</title>
    <link href="/2021/08/31/GDB%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/08/31/GDB%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="GDB调试过程"><a href="#GDB调试过程" class="headerlink" title="GDB调试过程"></a>GDB调试过程</h1><p>为了可以使用GDB调试，在编译的时候需要加入一些参数指令，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">gcc -g -Wall program.c -o program<br></code></pre></td></tr></table></figure><p><code>-g</code>的作用是在可执行文件中加入一些源代码信息，指明我当前执行的可执行文件中的机器指令对应着源代码的第几行代码</p><p><code>-Wall</code>的作用显示所有的警告信息</p><h2 id="GDB常用的调试命令"><a href="#GDB常用的调试命令" class="headerlink" title="GDB常用的调试命令"></a>GDB常用的调试命令</h2><ul><li><p>启动/退出：<code>gdb 文件名</code>、<code>quit</code></p></li><li><p>设置参数/显示参数：<code>set args var1 var2</code>、<code>show args</code></p></li><li><p>GDB使用帮助：<code>help</code></p></li><li><p>查看当前文件代码：<code>list</code></p></li><li><p>设置断点：<code>break 行号</code>、<code>break 函数名 </code></p><ul><li>查看断点信息：<code>info break</code></li><li>打了断点之后启动GDB调试：<code>start（程序停在第一行）</code>、<code>run（程序停在第一个断点处）</code></li><li>向下单步调试：<code>step</code>，遇到函数体会进入函数体；<code>next</code></li><li>打印变量的值/类型：<code>print 变量名</code>；<code>ptype 变量名</code></li></ul></li><li><p>多线程调试：</p><ul><li><p>显示所有的线程：<code>info threads</code>，显示所有可以调试的线程ID，这个ID是GDB分配的，从1开始，和线程ID不是同一个东西</p></li><li><p>切换线程：<code>thread ID</code></p></li><li><p>线程锁：<code>set scheduler-locking off|on</code></p><ul><li>on：表示锁定其他线程，只有当前线程可以执行</li><li>off：不锁定任何线程，当程序运行的时候如果有断点，那么所有的线程都会停止下来，如果在当前线程下启动continue，那么会启动所有的线程</li></ul></li><li><p>non-stop模式：某个线程中断在断点处，其他的线程继续运行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">set target-async <span class="hljs-number">1</span><br>set pagination off<br>set non-stop on<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>结构体内存对齐</title>
    <link href="/2021/08/31/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <url>/2021/08/31/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="C-中的结构体内存对齐"><a href="#C-中的结构体内存对齐" class="headerlink" title="C++中的结构体内存对齐"></a>C++中的结构体内存对齐</h1><p>首先来看一下常见的数据类型占用的内存大小：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%A4%A7%E5%B0%8F.png"></p><p>对于基本数据类型32位主机和64位主机是相同的，不同的只有指针的大小。</p><p>结构体内存对齐的原因是可以提高内存的访问速度。</p><p>结构体内存对齐遵循两个规则：</p><ul><li>数组成员对齐规则：首个元素放在偏移地址是0的位置，以后每个元素的偏移地址遵循<code>min(当前变量的字节大小，#pragma pack(n))</code>整数倍开始的地方，在windows中<code>#pragma pack</code>是8，在Linux中是4。</li><li>结构体大小（sizeof）规则：<code>min(数据成员最大的那个所占字节数，#pragma pack(n))</code>的整数倍</li><li>结构体作为成员的对齐规则：如果结构体B中嵌套了结构体A，那么还是以A中的最大数据成员大小来进行对齐，<code>min(结构体A中数据成员最大的那个所占字节数，#pragma pack(n))</code>。比如结构体A中有char、int、double等成员，那么B中A的偏移地址应该从8的整数倍开始存储。</li></ul><p>参考示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)   <span class="hljs-comment">// 16 8 4 2 1</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">double</span> c;<br>    <span class="hljs-type">float</span> d;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student2</span><br>&#123;<br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> b;<br>    <span class="hljs-type">double</span> c;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;#pragma pack(4)\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">offsetof</span>(<span class="hljs-keyword">struct</span> Student, a));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">offsetof</span>(<span class="hljs-keyword">struct</span> Student, b));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">offsetof</span>(<span class="hljs-keyword">struct</span> Student, c));<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Student));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">test</span>();<br><span class="hljs-comment">//输出:</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> pack(4)</span><br><span class="hljs-number">0</span><br><span class="hljs-number">4</span><br><span class="hljs-number">8</span><br><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>智能指针</title>
    <link href="/2021/08/31/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2021/08/31/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>通常在堆上申请内存，使用的是<code>new</code>关键字，指针如果不用了，要进行手动释放，防止产生内存错误。</p><p>C++11之后提供了三种智能指针可以使用，分别是<code>shared_ptr&lt;&gt;</code>、<code>unique_ptr&lt;&gt;</code>、<code>weak_ptr</code>,weak_ptr需要和shared_ptr来搭配使用。</p><p>智能指针是一个模板类，并不是指针，不能用指针直接对其赋值。</p><p>使用方式和普通指针类似，通过解引用可以获得指向的对象。</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>共享指针允许多个指针使用同一个资源，每一个shared_ptr都有一个关联的计数器，通常叫做引用计数，无论是拷贝还是赋值操作，都会记录当前有多少个指针指向相同的对象。</p><p>如果引用计数变为0，则会释放指针指向的对象。</p><p>使用get()函数可以获得原始指针。</p><p>具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptra = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(a);<br>    <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptra2</span><span class="hljs-params">(ptra)</span></span>; <span class="hljs-comment">//copy</span><br>    std::cout &lt;&lt; ptra.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<span class="hljs-comment">//2</span><br>    std::cout &lt;&lt; ptra2.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<span class="hljs-comment">//2</span><br><br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span> *pb = &amp;a;<br>    <span class="hljs-comment">//std::shared_ptr&lt;int&gt; ptrb = pb;  //error 不能用指针对智能指针直接赋值，因为智能指针是模板类</span><br>    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptrb = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(b);<br>    ptra2 = ptrb; <span class="hljs-comment">//assign</span><br>    pb = ptrb.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">//获取原始指针</span><br><br>    std::cout &lt;&lt; ptra.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<span class="hljs-comment">//1</span><br>    std::cout &lt;&lt; ptrb.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<span class="hljs-comment">//2</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>unique_ptr独有它的对象，同一时刻只能有一个指针指向一个给定的对象，它没有shared_ptr的make_shared函数来构建指针，必须通过new关键字直接初始化的方式：unique_ptr<int> p(new int(10))。</p><p>同样因为独有对象，所以不支持指针之间的拷贝和赋值，只能用move关键字来转移所有权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">uptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span></span>;  <span class="hljs-comment">//初始化</span><br>        <span class="hljs-comment">//std::unique_ptr&lt;int&gt; uptr2 = uptr;  //不能赋值</span><br>        <span class="hljs-comment">//std::unique_ptr&lt;int&gt; uptr2(uptr);  //不能拷贝</span><br>        std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; uptr2 = std::<span class="hljs-built_in">move</span>(uptr); <span class="hljs-comment">//转换所有权</span><br>        uptr2.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">//释放所有权</span><br>    &#125;<br>    <span class="hljs-comment">//超过uptr的作用域，内存释放</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>指向一个由shared_ptr共享的对象，但是不会改变shared_ptr的引用计数，如果引用计数变为0，即使仍然有weak_ptr指向对象，对象仍然会被释放。</p><p>因为对象可能不会存在，所以使用lock()来返回一个指向共享对象的shared_ptr。另外一个成员函数expired()等价于use_count()==0，但是更快。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sh_ptr = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br>        std::cout &lt;&lt; sh_ptr.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<span class="hljs-comment">//1</span><br><br>        <span class="hljs-function">std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">wp</span><span class="hljs-params">(sh_ptr)</span></span>;<br>        std::cout &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<span class="hljs-comment">//1</span><br><br>        <span class="hljs-keyword">if</span>(!wp.<span class="hljs-built_in">expired</span>())&#123;<br>            std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sh_ptr2 = wp.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">//get another shared_ptr</span><br>            *sh_ptr = <span class="hljs-number">100</span>;<br>            std::cout &lt;&lt; wp.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<span class="hljs-comment">//2</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//delete memory</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="智能指针底层实现原理"><a href="#智能指针底层实现原理" class="headerlink" title="智能指针底层实现原理"></a>智能指针底层实现原理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Smartpointer</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//一个指针、一个引用计数</span><br>    T*  _ptr;<br>    <span class="hljs-type">int</span>* _count;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//无参构造和有参构造</span><br>    <span class="hljs-built_in">Smartpointer</span>(T* ptr= <span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;_ptr=ptr;<br>        <span class="hljs-keyword">if</span> (ptr)&#123;<br>            <span class="hljs-keyword">this</span>-&gt;_count=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">this</span>-&gt;_count=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">Smartpointer</span>(<span class="hljs-type">const</span> Smartpointer&amp; p)&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>!=&amp;p)&#123;<br>            <span class="hljs-keyword">this</span>-&gt;_ptr=p._ptr;<br>            <span class="hljs-keyword">this</span>-&gt;_count= p._count;<br>            (*<span class="hljs-keyword">this</span>-&gt;_count)++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//拷贝赋值</span><br>    Smartpointer&amp; <span class="hljs-keyword">operator</span>=(Smartpointer&amp; p) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>==&amp;p)<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_ptr)&#123;<br>            *(<span class="hljs-keyword">this</span>-&gt;_count)--;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;_count==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br>                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;_ptr=p._ptr;<br>        <span class="hljs-keyword">this</span>-&gt;_count=p._count;<br>        (*<span class="hljs-keyword">this</span>-&gt;_count)++;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">//解引用重载</span><br>    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>*()&#123;<br>        <span class="hljs-keyword">return</span> *(<span class="hljs-keyword">this</span>-&gt;_ptr);<br>    &#125;<br><br>    <span class="hljs-comment">//指针重载</span><br>    T* <span class="hljs-keyword">operator</span>-&gt;()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br>    &#125;<br>    <span class="hljs-comment">//获取引用计数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">use_count</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (*<span class="hljs-keyword">this</span>-&gt;_count);<br>    &#125;<br><br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">Smartpointer</span>()&#123;<br>        <span class="hljs-comment">//首先只是将引用计数自减</span><br>        *(<span class="hljs-keyword">this</span>-&gt;_count)--;<br>        <span class="hljs-comment">//如果引用计数已经是0了，释放地址空间</span><br>        <span class="hljs-keyword">if</span> ((*<span class="hljs-keyword">this</span>-&gt;_count)==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_count;<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;_ptr;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中自定义sorted排序</title>
    <link href="/2021/08/22/Python%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89sorted%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/08/22/Python%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89sorted%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Python中sorted自定义排序规则"><a href="#Python中sorted自定义排序规则" class="headerlink" title="Python中sorted自定义排序规则"></a>Python中sorted自定义排序规则</h1><p>Python中有两个排序函数，一个是sorted，另外一个是sort，默认都是增序。sort只能对list进行排序，并且是原地修改，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">l=[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>]<br>l.sort()<span class="hljs-comment">#0 1 2 5</span><br></code></pre></td></tr></table></figure><p>sorted可以对任何容器进行排序，比如set，map，元组以及list，需要使用一个新的变量进行接收，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">#列表</span><br>l=[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>]<br>l=<span class="hljs-built_in">sorted</span>(l)<span class="hljs-comment">#[0, 1, 2, 5]</span><br><br><span class="hljs-comment">#元组 元组和列表的一个区别是列表可以修改，元组不可修改</span><br>t=(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)<br>t=<span class="hljs-built_in">sorted</span>(t)<span class="hljs-comment">#[0, 2, 4, 5]</span><br><br><span class="hljs-comment">#字典</span><br>m=&#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;hhh&#x27;</span>,<span class="hljs-number">2</span>:<span class="hljs-string">&quot;www&quot;</span>,<span class="hljs-number">0</span>:<span class="hljs-string">&#x27;ooo&#x27;</span>&#125;<br>m=<span class="hljs-built_in">sorted</span>(m)<span class="hljs-comment">#[0, 1, 2] 默认按照key进行排序，并将排序好的以列表的形式输出</span><br>m=<span class="hljs-built_in">sorted</span>(m.values()) <span class="hljs-comment"># 按照values进行排序，同样以列表的形式输出</span><br><br><span class="hljs-comment">#集合</span><br>s=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>&#125;<br>s=<span class="hljs-built_in">sorted</span>(s)<span class="hljs-comment">#[0, 1, 2, 4, 5, 7]</span><br></code></pre></td></tr></table></figure><p>如何自定义sorted排序呢，主要是通过key和reverse这两个关键字实现。</p><p>key用来确定当前使用的排序规则，结合lambda表达式使用。reverse表示反转的意思。因为默认是增序，如果设置reverse为True，则是降序排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python">l=[<span class="hljs-string">&quot;animal&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>,<span class="hljs-string">&#x27;dog&#x27;</span>,<span class="hljs-string">&#x27;camera&#x27;</span>]<br>l=<span class="hljs-built_in">sorted</span>(l,key=<span class="hljs-built_in">len</span>)<span class="hljs-comment"># 按照长度进行排序 [&#x27;dog&#x27;, &#x27;blue&#x27;, &#x27;animal&#x27;, &#x27;camera&#x27;]</span><br>l=<span class="hljs-built_in">sorted</span>(l,key=<span class="hljs-built_in">len</span>,reverse=<span class="hljs-literal">True</span>)<span class="hljs-comment"># [&#x27;animal&#x27;, &#x27;camera&#x27;, &#x27;blue&#x27;, &#x27;dog&#x27;]</span><br><br>l=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">10</span>]]<br>l=<span class="hljs-built_in">sorted</span>(l,key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])<span class="hljs-comment"># [[3, 1], [1, 2], [4, 5], [5, 10]]</span><br><span class="hljs-comment"># lambda可以有多个传入参数，但是表达式只能有一个</span><br><br>m=&#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;dog&#x27;</span>,<span class="hljs-number">4</span>:<span class="hljs-string">&#x27;camera&#x27;</span>,<span class="hljs-number">0</span>:<span class="hljs-string">&#x27;apple&#x27;</span>&#125;<br>mm=<span class="hljs-built_in">sorted</span>(m.items(),key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])<span class="hljs-comment">#[(0, &#x27;apple&#x27;), (4, &#x27;camera&#x27;), (1, &#x27;dog&#x27;)]</span><br><span class="hljs-comment"># x传入的是字典元组(1,&#x27;dog&#x27;),x[1]表示按照value排序，x[0]按照key排序，也可以对x[1]执行len(x[1])按照长度排序</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的sort自定义排序</title>
    <link href="/2021/08/22/C++%E4%B8%AD%E7%9A%84sort%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/"/>
    <url>/2021/08/22/C++%E4%B8%AD%E7%9A%84sort%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="C-中的sort自定义排序"><a href="#C-中的sort自定义排序" class="headerlink" title="C++中的sort自定义排序"></a>C++中的sort自定义排序</h1><h2 id="使用外部排序函数"><a href="#使用外部排序函数" class="headerlink" title="使用外部排序函数"></a>使用外部排序函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&gt;y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; t&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(),t.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//1,2,3,5 默认的是增序排序</span><br>    <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">rbegin</span>(),t.<span class="hljs-built_in">rend</span>());<span class="hljs-comment">//降序排序</span><br>    <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(),t.<span class="hljs-built_in">end</span>(),cmp);<span class="hljs-comment">//5,3,2,1 因为进行比较的时候当前位置X&gt;y返回的是true，所以是降序排序 </span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lambda表示法"><a href="#lambda表示法" class="headerlink" title="lambda表示法"></a>lambda表示法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; t&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(),t.<span class="hljs-built_in">end</span>(),[](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)&#123;<span class="hljs-keyword">return</span> x&gt;y;&#125;);<span class="hljs-comment">//5 3 2 1</span><br>    <br><span class="hljs-comment">//如果说这里使用了外部相关变量，比如说是对map中的val进行比较，可以在[]中使用&amp;符号 </span><br>unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; tmp&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">0</span>&#125;&#125;;<br><span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(),t.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)&#123;<span class="hljs-keyword">return</span> tmp[x]&gt;tmp[y];&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的深拷贝和浅拷贝，并以String为例</title>
    <link href="/2021/08/22/C++%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%B9%B6%E4%BB%A5String%E4%B8%BA%E4%BE%8B/"/>
    <url>/2021/08/22/C++%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%B9%B6%E4%BB%A5String%E4%B8%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="C-中的深拷贝和浅拷贝，并以String为例"><a href="#C-中的深拷贝和浅拷贝，并以String为例" class="headerlink" title="C++中的深拷贝和浅拷贝，并以String为例"></a>C++中的深拷贝和浅拷贝，并以String为例</h1><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>用一个类的对象去初始化另一个相同类的对象，如果在类中没有显示的定义拷贝构造函数，则编译器会生成一个默认的构造函数，这个构造函数通常是浅拷贝。</p><p>那么什么是浅拷贝呢？浅拷贝就是逐个字节的拷贝，如果是基本的数据类型，那么它是一份独立的拷贝，修改不同对象的值，不会相互影响；如果是引用数据类型，如对象、指针，那么他们是指向内存中的同一块地址。具体如下列代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>* s;<span class="hljs-comment">//s指向一个int型的指针数组</span><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> _data,<span class="hljs-type">int</span> _s)&#123;<br>        data=_data;<br>        s=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[_s];<br>        <span class="hljs-built_in">memset</span>(s,<span class="hljs-number">0</span>,_s*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<span class="hljs-comment">//memset函数设置的值只能是0和-1两种整数类型或者字符，因为其是按照字节来进行赋值</span><br>    &#125;<br>    ~<span class="hljs-built_in">A</span>()&#123;<br>        <span class="hljs-keyword">delete</span> []s;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;<br>    cout&lt;&lt;a.data&lt;&lt;endl;<span class="hljs-comment">//5</span><br>    cout&lt;&lt;b.data&lt;&lt;endl;<span class="hljs-comment">//5</span><br>    b.data=<span class="hljs-number">10</span>;<br>    cout&lt;&lt;a.data&lt;&lt;endl;<span class="hljs-comment">//5</span><br>    cout&lt;&lt;b.data&lt;&lt;endl;<span class="hljs-comment">//10</span><br><br>    cout&lt;&lt;a.s[<span class="hljs-number">0</span>]&lt;&lt;endl;<span class="hljs-comment">//0</span><br>    cout&lt;&lt;b.s[<span class="hljs-number">0</span>]&lt;&lt;endl;<span class="hljs-comment">//0</span><br>    b.s[<span class="hljs-number">0</span>]=<span class="hljs-number">100</span>;<br>    cout&lt;&lt;a.s[<span class="hljs-number">0</span>]&lt;&lt;endl;<span class="hljs-comment">//100</span><br>    cout&lt;&lt;b.s[<span class="hljs-number">0</span>]&lt;&lt;endl;<span class="hljs-comment">//100</span><br>    <br>    <span class="hljs-comment">//析构函数调用,先执行a.~A(),已经将内存中的数据释放掉了</span><br>    a.~<span class="hljs-built_in">A</span>();<br>    b.~<span class="hljs-built_in">A</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>浅拷贝会出现一个问题就是析构函数对同一块地址的重复释放，在上述代码中，如果我们显示的调用析构函数，就会发生错误，产生悬垂指针。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>对于类中有指针这种情况，我们需要手动创建拷贝构造函数或者重载赋值运算符，深拷贝是将原先内存中的数据拷贝一份，放到新申请的内存中，并使用一个新的指针指向它。具体代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span>&#123;<br><span class="hljs-keyword">private</span> :<br>    <span class="hljs-type">char</span>* m_data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str=<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//拷贝构造函数</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;str);<br>    <span class="hljs-comment">//重载赋值</span><br>    String&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String&amp; str);<br>    <span class="hljs-comment">//析构函数</span><br>    ~<span class="hljs-built_in">String</span>();<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span> </span>&#123;<br>    <span class="hljs-comment">//如果使用值进行初始化，拷贝过来并增加一个\0表示字符串结束</span><br>    <span class="hljs-keyword">if</span> (str)&#123;<br>        m_data=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(m_data,str);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        m_data=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>        *m_data=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">String::String</span><span class="hljs-params">(<span class="hljs-type">const</span> String &amp;str)</span> </span>&#123;<br>    m_data=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.m_data)+<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">strcpy</span>(m_data,str.m_data);<br>&#125;<br><br><span class="hljs-comment">//操作符重载一定是作用在左边的变量上</span><br><span class="hljs-comment">//类内操作符重载（作为成员函数）操作符一定是两个形参，但是在类内来写只有一个形参，this形参被省略</span><br><span class="hljs-keyword">inline</span> String &amp;String::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> String &amp;str) &#123;<br>    <span class="hljs-comment">//如果是字符串本身直接等于即可</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>==&amp;str)&#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">delete</span>[] str.m_data;<br>        m_data=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.m_data)+<span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(m_data,str.m_data);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">inline</span> String::~<span class="hljs-built_in">String</span>() &#123;<br>    <span class="hljs-keyword">delete</span>[] m_data;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map和set</title>
    <link href="/2021/08/19/map%E5%92%8Cset/"/>
    <url>/2021/08/19/map%E5%92%8Cset/</url>
    
    <content type="html"><![CDATA[<p>map和set</p><p>关联容器支持高效的关键字查找和访问。两个主要的关联容器是map和set，map中的元素是键值对。</p><table><thead><tr><th>有序</th><th>介绍</th></tr></thead><tbody><tr><td>map</td><td>保存键值对</td></tr><tr><td>set</td><td>只保存关键字</td></tr><tr><td>multimap</td><td>关键字可以重复出现</td></tr><tr><td>multiset</td><td>关键字可以重复出现</td></tr><tr><td><strong>无序</strong></td><td></td></tr><tr><td>unordered_map</td><td>用哈希函数组织的map</td></tr><tr><td>unordered_set</td><td>用哈希函数组织的set</td></tr><tr><td>unordered_multimap</td><td>用哈希函数组织的map:关键字可以重复出现</td></tr></tbody></table><p>分别给出最适合使用<code>list</code>、<code>vector</code>、<code>deque</code>、<code>map</code>以及<code>set</code>的例子。</p><ul><li><p><code>list</code>：双向链表，适合频繁插入删除元素的场景。</p></li><li><p><code>vector</code>：适合频繁访问元素的场景。</p></li><li><p><code>deque</code>：双端队列，适合频繁在头尾插入删除元素的场景。</p></li><li><p><code>map</code>：字典。</p></li><li><p><code>set</code>：适合有序不重复的元素的场景。</p></li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map</code>的特性是所有元素都会根据键值自动排序，<code>map</code>的所有元素都是<code>pair</code>，同时拥有键值和实值。不允许两个相同的元素具有相同的键值。</p><h4 id="可以通过map的迭代器改变元素内容吗？"><a href="#可以通过map的迭代器改变元素内容吗？" class="headerlink" title="可以通过map的迭代器改变元素内容吗？"></a>可以通过<code>map</code>的迭代器改变元素内容吗？</h4><p>如果想要修改元素的键值，是不可以的。因为键值关乎到<code>map</code>元素的排列规则。但是如果想要修改实值是可以的，因为实值并不影响元素的排列规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++C++">map&lt;int,string&gt; mymap&#123;&#123;1,&quot;hello&quot;&#125;,&#123;2,&quot;world&quot;&#125;,&#123;3,&quot;use&quot;&#125;,&#123;4,&quot;C++&quot;&#125;&#125;;<br>auto it = mymap.begin();<br><br>while(it!=mymap.end())&#123;<br>cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;<br>++it;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>map</code>的一些操作和<code>list</code>相似，行元素新增操作或者删除操作时，操作之前的所有的迭代器操作完成之后依然都有效。</p><h3 id="map的定义"><a href="#map的定义" class="headerlink" title="map的定义"></a>map的定义</h3><p>定义map时必须既指明关键字类型又指明值类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;string,<span class="hljs-type">size_t</span>&gt; word_count;<span class="hljs-comment">//空容器</span><br>map&lt;string,string&gt; authors=&#123;&#123;<span class="hljs-string">&quot;Joyce&quot;</span>,<span class="hljs-string">&quot;James&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;Austen&quot;</span>,<span class="hljs-string">&quot;Jane&quot;</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><h3 id="map的查找和遍历"><a href="#map的查找和遍历" class="headerlink" title="map的查找和遍历"></a>map的查找和遍历</h3><ul><li>使用迭代器进行遍历</li><li>数组形式，index为key</li><li>find查找指定的key</li></ul><h4 id="find和count"><a href="#find和count" class="headerlink" title="find和count"></a>find和count</h4><p>使用<em>find</em>和<em>count</em>函数，可以通过<em>find</em>查找指定的关键字是否出现，count函数返回的是一个容器中，某一元素出现的次数，对于map，即返回key出现的次数，但是map中的key是不允许重复出现的，故count函数返回值只能是1（存在）或0（不存在）。</p><p>使用find，返回的是一个迭代器，若容器中不存在该关键字则返回<em>map.end()</em><br>如：要找到某一个key的value值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mymap;<br><span class="hljs-keyword">if</span>(mymap.<span class="hljs-built_in">find</span>(key)!=mymap.<span class="hljs-built_in">end</span>())&#123;<br>    cout&lt;&lt;mymap.<span class="hljs-built_in">find</span>(key)-&gt;second&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数组形式"><a href="#数组形式" class="headerlink" title="数组形式"></a>数组形式</h4><p><em>map</em>中可以使用下标运算符和对应的*at( )*函数，但是set类型不支持下标，因为set中没有与关键字相关联的“值”，元素本身就是关键字。map下标运算符接收一个索引，获取与此关键字相关联的值，如果关键字并不在map中，则为它创建一个元素插入到map中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">map&lt;string,<span class="hljs-type">sizet_t</span>&gt; word_count;<span class="hljs-comment">//空map</span><br>word_count[<span class="hljs-string">&quot;Anna&quot;</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//在word_count中搜索关键字为Anna的元素，未找到，则进行插入操作。</span><br>word.<span class="hljs-built_in">at</span>(<span class="hljs-string">&quot;Anna&quot;</span>);<span class="hljs-comment">//访问关键字为Anna的值</span><br></code></pre></td></tr></table></figure><h3 id="map中插入元素"><a href="#map中插入元素" class="headerlink" title="map中插入元素"></a>map中插入元素</h3><p>对map中进行insert操作时，元素类型必须是pair类型，因此在insert的参数列表中创建一个pair。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">word_count.<span class="hljs-built_in">insert</span>(&#123;word,<span class="hljs-number">1</span>&#125;);<br>word_count.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(word,<span class="hljs-number">1</span>));<br>word_count.<span class="hljs-built_in">insert</span>(map&lt;string,<span class="hljs-type">size_t</span>&gt;::<span class="hljs-built_in">value_type</span>(word,<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h3 id="map的删除"><a href="#map的删除" class="headerlink" title="map的删除"></a>map的删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">iterator erase（iterator it);<span class="hljs-comment">//通过一个条目对象删除</span><br>iterator erase（iterator first，iterator last）<span class="hljs-comment">//删除一个范围</span><br><span class="hljs-function">size_type <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp;key)</span></span>;<span class="hljs-comment">//通过关键字删除</span><br></code></pre></td></tr></table></figure><h2 id="map和unordered-map区别"><a href="#map和unordered-map区别" class="headerlink" title="map和unordered_map区别"></a>map和unordered_map区别</h2><h3 id="内部实现机理不同"><a href="#内部实现机理不同" class="headerlink" title="内部实现机理不同"></a>内部实现机理不同</h3><p><strong>map：</strong>内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部都是有序的红黑树，每一个节点都代表着map的一个元素。</p><p><strong>unordered_map：</strong>内部实现了一个哈希表（把关键值映射到hash表中的一个位置来访问，查找时间复杂度可以达到O(1)，在海量数据处理中有广泛应用）</p><p><strong>map</strong>的<code>key</code>可以是任何类型，但是unordered_map的<code>key</code><strong>只能是C++中定义的关键字类型</strong></p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p><code>set</code>的特性是所有元素都会根据键值自动排序，<code>set</code>中元素的键值就是实值，实值就是键值，<code>set</code>不允许两个元素具有相同的键值。</p><h4 id="是否可以通过迭代器来改变set元素值？"><a href="#是否可以通过迭代器来改变set元素值？" class="headerlink" title="是否可以通过迭代器来改变set元素值？"></a>是否可以通过迭代器来改变<code>set</code>元素值？</h4><p>不可以。</p><p>因为<code>set</code>的元素值就是键值，关系到set元素的排列规则，如果任意改变set的元素值会严重破坏<code>set</code>组织。从<code>set</code>的源码中可以看到，``set<T>::iterator<code>被定义为底层红黑树的</code>const_iterator`。</p><p><code>set</code>具有和<code>list</code>相同的某些性质，当对<code>set</code>进行元素新增操作或者删除操作时，操作之前的所有的迭代器操作完成之后依然都有效。</p><h3 id="与set声明和常见API"><a href="#与set声明和常见API" class="headerlink" title="与set声明和常见API"></a>与set声明和常见API</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">vector&lt;<span class="hljs-type">int</span>&gt; myvec=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;<br>set&lt;<span class="hljs-type">int</span>&gt; myset;<span class="hljs-comment">//声明</span><br>myset.<span class="hljs-built_in">insert</span>(myvec.<span class="hljs-built_in">cbegin</span>(),myvec.<span class="hljs-built_in">cend</span>());<span class="hljs-comment">//新增4个元素</span><br>myset.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;)<span class="hljs-comment">//新增4个元素</span><br>myset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//新增一个元素</span><br><br>myset.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//set中元素的个数</span><br>myset.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//删除set中的所有元素</span><br>myset.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//判断set是否为空</span><br>myset.<span class="hljs-built_in">max_size</span>();<span class="hljs-comment">//返回容器中可能包含的元素的最大个数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图解HTTP笔记</title>
    <link href="/2021/08/12/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/12/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>图解HTTP阅读笔记</p><h2 id="OSI七层和TCP-IP四层模型"><a href="#OSI七层和TCP-IP四层模型" class="headerlink" title="OSI七层和TCP/IP四层模型"></a>OSI七层和TCP/IP四层模型</h2><p><img src="/images/%E6%88%AA%E5%9B%BE.png"></p><h2 id="TCP-IP中数据发送过程"><a href="#TCP-IP中数据发送过程" class="headerlink" title="TCP/IP中数据发送过程"></a>TCP/IP中数据发送过程</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B.png"></p><h2 id="HTTP协议关系密切的三个协议"><a href="#HTTP协议关系密切的三个协议" class="headerlink" title="HTTP协议关系密切的三个协议"></a>HTTP协议关系密切的三个协议</h2><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议位于网络层，它的主要作用就是将各种数据包传送给对方，其需要两个重要的地址，一个是IP地址，另外一个是MAC地址</p><p>IP在传送各种数据包的时候，并不是直接发送到目标主机上，而是通过路由中转，类似于现实中的快递中转策略一样。</p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP协议在传输层，提供字节流服务。它将上层的HTTP中的数据切割为一个个的报文段来方便传输，并且提供的是可靠传输。</p><p>在TCP建立连接之前，需要进行三次握手，三次握手过程中有一个非常重要的标志即SYN和ACK</p><p><img src="/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><h3 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h3><p>DNS是域名解析协议，负责将域名解析为IP地址。</p><h3 id="各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）"><a href="#各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）" class="headerlink" title="各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）"></a>各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）</h3><p><img src="/images/URL%E8%BE%93%E5%85%A5%E4%B9%8B%E5%90%8E%E7%9A%84%E8%BF%87%E7%A8%8B.png"></p><h2 id="HTTP协议结构基础"><a href="#HTTP协议结构基础" class="headerlink" title="HTTP协议结构基础"></a>HTTP协议结构基础</h2><p>HTTP是一种请求响应式协议，通信过程必须要有一个客户端和一个服务端，通过客户端发起请求，服务端进行响应。传输过程对消息内容进行压缩编码和分块传输。</p><p><img src="/images/%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94.png"></p><h3 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h3><p><img src="/images/%E8%AF%B7%E6%B1%82%E6%8A%A5%E5%A4%B4.png"></p><p><img src="/images/%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8.png"></p><p>起始行开头的GET和POST方法表示请求访问服务器的类型，叫方法。GET获取服务器的资源，POST向服务器发送信息</p><p><em>GET和POST方法都是安全和幂等的吗？</em></p><ul><li><p><em>安全：在HTTP协议中，安全是指请求的方法不会破坏服务器上的资源</em></p></li><li><p><em>幂等：多次执行相同的操作结果都是相同的</em></p></li><li><p><em>GET方法是安全且幂等的，因为其是只读操作，POST方法是不安全且不幂等的</em></p></li></ul><p>紧接着的URI表示请求访问的资源对象</p><p>HOST是服务器域名，因为同一个服务器上使用虚拟主机的方式可能会部署多个域名，但是经过DNS解析之后，这些域名都指向同一个IP地址，因此用HOST来区分</p><p>HTTP/1.1，指明HTTP版本号</p><p>Connection字段：用来管理持久连接，HTTP/1.1版本默认都是持久连接，旧版本不是，需要指定该字段为Keep-alive，如果想要断开连接，指定为close</p><p>Accept字段：表明客户端可以接受的内容格式</p><p>Accept-Encoding字段：客户端支持的内容编码</p><p>Accept-Language字段：客户端能够处理的语言类型</p><h3 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h3><p><img src="/images/%E5%93%8D%E5%BA%94%E6%8A%A5%E5%A4%B4.png"></p><p>HTTP/1.1表示服务器对应的HTTP版本</p><p>200 OK 是请求处理结果的状态码</p><h3 id="HTTP的无状态属性"><a href="#HTTP的无状态属性" class="headerlink" title="HTTP的无状态属性"></a>HTTP的无状态属性</h3><p>http协议是无状态协议，不对之前的请求和响应进行保存。比如登录淘宝网址，如果不对登录的情况进行保存，每次跳转都要进行重新登录，这是非常麻烦的，但是如果让服务器记录每个客户端的状态，也不现实，不符合HTTP轻量化设计的初衷</p><p><strong>引用Cookie技术来保存状态，在请求和响应报文中写入Cookie信息</strong></p><p>初次客户端向服务端发送请求报文，服务端会在响应报文中添加一个Set-Cookie字段，设置Cookie值；客户端收到响应后，会保存这个Cookie值，并在下次请求报文中加上这个Cookie值，这样服务端就可以根据Cookie值来判断请求消息来自于那个客户端。对比服务器上的记录，得到之前的状态信息</p><p><img src="/images/Cookie.png"></p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>在HTTP协议的最初版本中每进行一次HTTP的通信，就要进行一次的TCP连接和断开，增加通信量的开销</p><p>HTTP/1.1和部分HTTP/1.0支持持久连接，也称为Keep-alive方法，即一次TCP连接，多次进行HTTP的请求和响应，直到一端提出明确的断连</p><p><img src="/images/%E6%8C%81%E4%B9%85%E5%8C%96.png"></p><h3 id="管线化技术"><a href="#管线化技术" class="headerlink" title="管线化技术"></a>管线化技术</h3><p>管线化技术是建立在持久连接基础之上的，以往客户端都是发送一个请求然后等待服务器响应，然后再发送下一个请求。管线化技术中，客户端可以连续发送多个请求而不等待服务端的响应，服务端在收到多个请求后，挨个发送响应</p><p><img src="/images/%E7%AE%A1%E7%BA%BF%E5%8C%96.png"></p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>服务器通过状态码来表示对客户端请求响应的处理结果，常见的状态码主要有五类，如下图所示：</p><p><img src="/images/%E7%8A%B6%E6%80%81%E7%A0%81.png"></p><h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3><ul><li>200  OK：客户端请求被正常处理</li><li>204  No Content：服务器正常处理请求，但是没有内容返回</li></ul><h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3><ul><li>301  Moved Permanently：表示客户端请求的资源已经被分配给新的URI，应该使用新的URI进行访问</li><li>302  FOUND：资源临时被分到新的URI去了</li></ul><h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3><ul><li>400  Bad Request：表示请求报文中有错误</li><li>401  Unauthorized：表名请求没有通过HTTP认证</li><li>403  Forbidden：服务器拒绝客户端对请求资源的访问</li><li>404  Not Found：服务器上没有请求访问的资源</li></ul><h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3><ul><li>500  Internal Server Error：服务器处理请求时发生错误</li><li>503  Service Unavailable：表明服务器当前可能停机维护，不能处理请求</li></ul><h3 id="HTTP的优点和缺点"><a href="#HTTP的优点和缺点" class="headerlink" title="HTTP的优点和缺点"></a>HTTP的优点和缺点</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>简单：报文格式就是Header+Body，头部信息也是简单的key-value形式</li><li>灵活和易扩展：协议中的各种请求方法、URI/URL、状态码、头字段等各个组成部分，允许开发人员自定义和扩充</li><li>应用广发和跨平台</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法验证报文的完整性，所以有可能遭遇篡改</li><li>无状态传输</li></ul><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTP协议是直接和TCP进行通信，而HTTPS则是HTTP先和SSL进行通信，再由SSL和TCP进行通信。简单来说，HTTPS就是披着SSL外衣的HTTP通信   </p><p>TLS是在SSL为原型开发的协议，有时统一将它们称为SSL </p><p><img src="/images/HTTPS%E5%92%8CHTTP.png"></p><p>使用了SSL，HTTP就有了加密、证书和完整性保护的功能了</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密使用同一个密钥的方式叫做对称加密，在发送加密内容时也必须将密钥发送给对方，这样一旦密钥被劫持就可以对加密内容进行解密。</p><p>SSL使用就是这种加密方式</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密具有两把密钥，公钥可以随意发送，但是私钥只有自己知道。</p><p>发送密文的一方，使用对方发送过来的公钥进行加密内容，对方在收到密文之后，使用自己的私钥进行解密。</p><h3 id="HTTPS使用混合加密的方式"><a href="#HTTPS使用混合加密的方式" class="headerlink" title="HTTPS使用混合加密的方式"></a>HTTPS使用混合加密的方式</h3><p>非对称加密虽然可以确保信息不会被窃听的风险，但是非对称加密在对内容加密的时候，处理速度非常的慢，没有对称加密那样快，所以先使用非对称加密来加密对称加密的密钥，交换密钥成功之后，再使用对称加密的方式来进行通信。  </p><p><img src="/images/%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png"></p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>为了验证公开密钥是安全的，因此客户端和服务端会向数字认证证书机构CA来来申请数字证书签名</p><h3 id="HTTPS的安全通信过程"><a href="#HTTPS的安全通信过程" class="headerlink" title="HTTPS的安全通信过程"></a>HTTPS的安全通信过程</h3><p><img src="/images/HTTPS%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png"></p><ol><li>客户端通过发送ClientHELLO报文开始SSL通信，包括客户端支持的SSL版本，所使用的加密组件（加密算法和密钥长度）</li><li>服务器收到后，以SEVERHELLO作为回应，同样包含SSL版本和加密组件（和客户端相同）</li><li>服务器向客户端发送公开密钥证书</li><li>服务器发送SeverHelloDone，表示最初的SSL握手协商结束</li><li>客户端向服务器发送Pre-master secret随机密码串，随机密码串已经使用公开密钥进行加密</li><li>客户端继续向服务端发送报文，表示之后的内容都会使用随机密码串Pre-master secret进行加密</li><li>客户端发送结束报文，这个报文包含至今全部报文的校验值，握手协商是否已经成功，要以服务器是否能够对本次的内容进行成功解密</li><li>服务器同样发送ChangeCiperSpec报文，表明已经知道使用Pre-master对内容进行加密</li><li>服务器发送Finished报文，至此SSL连接已经建立完成，后续的通信都会受到SSL的保护</li><li>客户端向服务器发起请求</li><li>服务端向客户端发起响应</li><li>客户端发起断开连接请求</li></ol><p>在之上的流程中，应用层发送数据时会附加一个MAC（message Authentication Code）的报文摘要，能够用来验证报文是否遭受篡改，保护报文的完整性</p><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ul><li>HTTP是明文传输，HTTPS是加密传输、</li><li>HTTP在TCP三次握手之后，就可以进行内容传输，HTTPS还要进行SSL/TLS四次握手</li><li>HTTP的端口号是80，HTTPS是443</li><li>HTTPS需要向CA申请数字证书，来证明服务器的身份是可信的</li></ul><h2 id="HTTP的缺陷和改进"><a href="#HTTP的缺陷和改进" class="headerlink" title="HTTP的缺陷和改进"></a>HTTP的缺陷和改进</h2><h3 id="HTTP-1-1对HTTP-1-0的改进"><a href="#HTTP-1-1对HTTP-1-0的改进" class="headerlink" title="HTTP/1.1对HTTP/1.0的改进"></a>HTTP/1.1对HTTP/1.0的改进</h3><ul><li>使用TCP长连接</li><li>支持管道传输</li></ul><p>缺陷</p><ul><li>请求只能从客户端进行发送，客户端不能接受除了响应之外的任何指令</li><li>请求/响应的首部未经压缩就发送，首部信息越多，延迟就会越大</li><li>发送冗长的首部，每次都是发送相同的首部造成很大的浪费</li><li>按照请求的顺序对其进行响应，如果之前的某个请求没有响应，后续的就会堵塞，这就是对头堵塞</li></ul><h3 id="HTTP2对HTTP-1-1的改进"><a href="#HTTP2对HTTP-1-1的改进" class="headerlink" title="HTTP2对HTTP/1.1的改进"></a>HTTP2对HTTP/1.1的改进</h3><p>HTTP2是基于HTTPS的，所以其也是加密传输，能够保证数据传输的安全性</p><ul><li>服务器推送：在HTTP2中服务器也可以主动向客户端推送消息，不再是完全传统的请求相应式工作模式</li><li>头部压缩：如果客户端同时发送多个请求，这些请求的头部相似或者完全一样，协议就会消除这些重复的部分</li><li>多路复用：HTTP2可以并发多个请求和响应，不用按顺序对请求进行响应，避免了对头堵塞的问题</li><li>二进制格式：在HTTP2中数据不再是纯文本的格式，而全面是用二进制编码，报文首部变为头信息帧，报文主体变为数据帧，这样增加了数据传输的效率</li></ul><h3 id="HTTP3对HTTP2的改进"><a href="#HTTP3对HTTP2的改进" class="headerlink" title="HTTP3对HTTP2的改进"></a>HTTP3对HTTP2的改进</h3><p>HTTP2中多个请求复用一个TCP连接，底层TCP协议并不清楚有多少个请求，一旦发生丢包问题，就会触发TCP的重传机制，这样一个TCP连接中的所有HTTP请求都会等待这个被丢的包重传回来，因此HTTP3将下层的TCP协议变为了UDP协议</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
