<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图解HTTP笔记</title>
    <link href="/2022/08/12/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/08/12/%E5%9B%BE%E8%A7%A3HTTP%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>图解HTTP阅读笔记</p><h2 id="OSI七层和TCP-IP四层模型"><a href="#OSI七层和TCP-IP四层模型" class="headerlink" title="OSI七层和TCP/IP四层模型"></a>OSI七层和TCP/IP四层模型</h2><p><img src="/images/%E6%88%AA%E5%9B%BE.png"></p><h2 id="TCP-IP中数据发送过程"><a href="#TCP-IP中数据发送过程" class="headerlink" title="TCP/IP中数据发送过程"></a>TCP/IP中数据发送过程</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B.png"></p><h2 id="HTTP协议关系密切的三个协议"><a href="#HTTP协议关系密切的三个协议" class="headerlink" title="HTTP协议关系密切的三个协议"></a>HTTP协议关系密切的三个协议</h2><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议位于网络层，它的主要作用就是将各种数据包传送给对方，其需要两个重要的地址，一个是IP地址，另外一个是MAC地址</p><p>IP在传送各种数据包的时候，并不是直接发送到目标主机上，而是通过路由中转，类似于现实中的快递中转策略一样。</p><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP协议在传输层，提供字节流服务。它将上层的HTTP中的数据切割为一个个的报文段来方便传输，并且提供的是可靠传输。</p><p>在TCP建立连接之前，需要进行三次握手，三次握手过程中有一个非常重要的标志即SYN和ACK</p><p><img src="/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><h3 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h3><p>DNS是域名解析协议，负责将域名解析为IP地址。</p><h3 id="各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）"><a href="#各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）" class="headerlink" title="各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）"></a>各种协议和HTTP协议联合工作的过程（URL输入网址之后的过程）</h3><p><img src="/images/URL%E8%BE%93%E5%85%A5%E4%B9%8B%E5%90%8E%E7%9A%84%E8%BF%87%E7%A8%8B.png"></p><h2 id="HTTP协议结构基础"><a href="#HTTP协议结构基础" class="headerlink" title="HTTP协议结构基础"></a>HTTP协议结构基础</h2><p>HTTP是一种请求响应式协议，通信过程必须要有一个客户端和一个服务端，通过客户端发起请求，服务端进行响应。传输过程对消息内容进行压缩编码和分块传输。</p><p><img src="/images/%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94.png"></p><h3 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h3><p><img src="/images/%E8%AF%B7%E6%B1%82%E6%8A%A5%E5%A4%B4.png"></p><p><img src="/images/%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8.png"></p><p>起始行开头的GET和POST方法表示请求访问服务器的类型，叫方法。GET获取服务器的资源，POST向服务器发送信息</p><p><em>GET和POST方法都是安全和幂等的吗？</em></p><ul><li><p><em>安全：在HTTP协议中，安全是指请求的方法不会破坏服务器上的资源</em></p></li><li><p><em>幂等：多次执行相同的操作结果都是相同的</em></p></li><li><p><em>GET方法是安全且幂等的，因为其是只读操作，POST方法是不安全且不幂等的</em></p></li></ul><p>紧接着的URI表示请求访问的资源对象</p><p>HOST是服务器域名，因为同一个服务器上使用虚拟主机的方式可能会部署多个域名，但是经过DNS解析之后，这些域名都指向同一个IP地址，因此用HOST来区分</p><p>HTTP/1.1，指明HTTP版本号</p><p>Connection字段：用来管理持久连接，HTTP/1.1版本默认都是持久连接，旧版本不是，需要指定该字段为Keep-alive，如果想要断开连接，指定为close</p><p>Accept字段：表明客户端可以接受的内容格式</p><p>Accept-Encoding字段：客户端支持的内容编码</p><p>Accept-Language字段：客户端能够处理的语言类型</p><h3 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h3><p><img src="/images/%E5%93%8D%E5%BA%94%E6%8A%A5%E5%A4%B4.png"></p><p>HTTP/1.1表示服务器对应的HTTP版本</p><p>200 OK 是请求处理结果的状态码</p><h3 id="HTTP的无状态属性"><a href="#HTTP的无状态属性" class="headerlink" title="HTTP的无状态属性"></a>HTTP的无状态属性</h3><p>http协议是无状态协议，不对之前的请求和响应进行保存。比如登录淘宝网址，如果不对登录的情况进行保存，每次跳转都要进行重新登录，这是非常麻烦的，但是如果让服务器记录每个客户端的状态，也不现实，不符合HTTP轻量化设计的初衷</p><p><strong>引用Cookie技术来保存状态，在请求和响应报文中写入Cookie信息</strong></p><p>初次客户端向服务端发送请求报文，服务端会在响应报文中添加一个Set-Cookie字段，设置Cookie值；客户端收到响应后，会保存这个Cookie值，并在下次请求报文中加上这个Cookie值，这样服务端就可以根据Cookie值来判断请求消息来自于那个客户端。对比服务器上的记录，得到之前的状态信息</p><p><img src="/images/Cookie.png"></p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>在HTTP协议的最初版本中每进行一次HTTP的通信，就要进行一次的TCP连接和断开，增加通信量的开销</p><p>HTTP/1.1和部分HTTP/1.0支持持久连接，也称为Keep-alive方法，即一次TCP连接，多次进行HTTP的请求和响应，直到一端提出明确的断连</p><p><img src="/images/%E6%8C%81%E4%B9%85%E5%8C%96.png"></p><h3 id="管线化技术"><a href="#管线化技术" class="headerlink" title="管线化技术"></a>管线化技术</h3><p>管线化技术是建立在持久连接基础之上的，以往客户端都是发送一个请求然后等待服务器响应，然后再发送下一个请求。管线化技术中，客户端可以连续发送多个请求而不等待服务端的响应，服务端在收到多个请求后，挨个发送响应</p><p><img src="/images/%E7%AE%A1%E7%BA%BF%E5%8C%96.png"></p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>服务器通过状态码来表示对客户端请求响应的处理结果，常见的状态码主要有五类，如下图所示：</p><p><img src="/images/%E7%8A%B6%E6%80%81%E7%A0%81.png"></p><h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3><ul><li>200  OK：客户端请求被正常处理</li><li>204  No Content：服务器正常处理请求，但是没有内容返回</li></ul><h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3><ul><li>301  Moved Permanently：表示客户端请求的资源已经被分配给新的URI，应该使用新的URI进行访问</li><li>302  FOUND：资源临时被分到新的URI去了</li></ul><h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3><ul><li>400  Bad Request：表示请求报文中有错误</li><li>401  Unauthorized：表名请求没有通过HTTP认证</li><li>403  Forbidden：服务器拒绝客户端对请求资源的访问</li><li>404  Not Found：服务器上没有请求访问的资源</li></ul><h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3><ul><li>500  Internal Server Error：服务器处理请求时发生错误</li><li>503  Service Unavailable：表明服务器当前可能停机维护，不能处理请求</li></ul><h3 id="HTTP的优点和缺点"><a href="#HTTP的优点和缺点" class="headerlink" title="HTTP的优点和缺点"></a>HTTP的优点和缺点</h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>简单：报文格式就是Header+Body，头部信息也是简单的key-value形式</li><li>灵活和易扩展：协议中的各种请求方法、URI/URL、状态码、头字段等各个组成部分，允许开发人员自定义和扩充</li><li>应用广发和跨平台</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法验证报文的完整性，所以有可能遭遇篡改</li><li>无状态传输</li></ul><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTP协议是直接和TCP进行通信，而HTTPS则是HTTP先和SSL进行通信，再由SSL和TCP进行通信。简单来说，HTTPS就是披着SSL外衣的HTTP通信   </p><p>TLS是在SSL为原型开发的协议，有时统一将它们称为SSL </p><p><img src="/images/HTTPS%E5%92%8CHTTP.png"></p><p>使用了SSL，HTTP就有了加密、证书和完整性保护的功能了</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密使用同一个密钥的方式叫做对称加密，在发送加密内容时也必须将密钥发送给对方，这样一旦密钥被劫持就可以对加密内容进行解密。</p><p>SSL使用就是这种加密方式</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称加密具有两把密钥，公钥可以随意发送，但是私钥只有自己知道。</p><p>发送密文的一方，使用对方发送过来的公钥进行加密内容，对方在收到密文之后，使用自己的私钥进行解密。</p><h3 id="HTTPS使用混合加密的方式"><a href="#HTTPS使用混合加密的方式" class="headerlink" title="HTTPS使用混合加密的方式"></a>HTTPS使用混合加密的方式</h3><p>非对称加密虽然可以确保信息不会被窃听的风险，但是非对称加密在对内容加密的时候，处理速度非常的慢，没有对称加密那样快，所以先使用非对称加密来加密对称加密的密钥，交换密钥成功之后，再使用对称加密的方式来进行通信。  </p><p><img src="/images/%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png"></p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>为了验证公开密钥是安全的，因此客户端和服务端会向数字认证证书机构CA来来申请数字证书签名</p><h3 id="HTTPS的安全通信过程"><a href="#HTTPS的安全通信过程" class="headerlink" title="HTTPS的安全通信过程"></a>HTTPS的安全通信过程</h3><p><img src="/images/HTTPS%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png"></p><ol><li>客户端通过发送ClientHELLO报文开始SSL通信，包括客户端支持的SSL版本，所使用的加密组件（加密算法和密钥长度）</li><li>服务器收到后，以SEVERHELLO作为回应，同样包含SSL版本和加密组件（和客户端相同）</li><li>服务器向客户端发送公开密钥证书</li><li>服务器发送SeverHelloDone，表示最初的SSL握手协商结束</li><li>客户端向服务器发送Pre-master secret随机密码串，随机密码串已经使用公开密钥进行加密</li><li>客户端继续向服务端发送报文，表示之后的内容都会使用随机密码串Pre-master secret进行加密</li><li>客户端发送结束报文，这个报文包含至今全部报文的校验值，握手协商是否已经成功，要以服务器是否能够对本次的内容进行成功解密</li><li>服务器同样发送ChangeCiperSpec报文，表明已经知道使用Pre-master对内容进行加密</li><li>服务器发送Finished报文，至此SSL连接已经建立完成，后续的通信都会受到SSL的保护</li><li>客户端向服务器发起请求</li><li>服务端向客户端发起响应</li><li>客户端发起断开连接请求</li></ol><p>在之上的流程中，应用层发送数据时会附加一个MAC（message Authentication Code）的报文摘要，能够用来验证报文是否遭受篡改，保护报文的完整性</p><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ul><li>HTTP是明文传输，HTTPS是加密传输、</li><li>HTTP在TCP三次握手之后，就可以进行内容传输，HTTPS还要进行SSL/TLS四次握手</li><li>HTTP的端口号是80，HTTPS是443</li><li>HTTPS需要向CA申请数字证书，来证明服务器的身份是可信的</li></ul><h2 id="HTTP的缺陷和改进"><a href="#HTTP的缺陷和改进" class="headerlink" title="HTTP的缺陷和改进"></a>HTTP的缺陷和改进</h2><h3 id="HTTP-1-1对HTTP-1-0的改进"><a href="#HTTP-1-1对HTTP-1-0的改进" class="headerlink" title="HTTP/1.1对HTTP/1.0的改进"></a>HTTP/1.1对HTTP/1.0的改进</h3><ul><li>使用TCP长连接</li><li>支持管道传输</li></ul><p>缺陷</p><ul><li>请求只能从客户端进行发送，客户端不能接受除了响应之外的任何指令</li><li>请求/响应的首部未经压缩就发送，首部信息越多，延迟就会越大</li><li>发送冗长的首部，每次都是发送相同的首部造成很大的浪费</li><li>按照请求的顺序对其进行响应，如果之前的某个请求没有响应，后续的就会堵塞，这就是对头堵塞</li></ul><h3 id="HTTP2对HTTP-1-1的改进"><a href="#HTTP2对HTTP-1-1的改进" class="headerlink" title="HTTP2对HTTP/1.1的改进"></a>HTTP2对HTTP/1.1的改进</h3><p>HTTP2是基于HTTPS的，所以其也是加密传输，能够保证数据传输的安全性</p><ul><li>服务器推送：在HTTP2中服务器也可以主动向客户端推送消息，不再是完全传统的请求相应式工作模式</li><li>头部压缩：如果客户端同时发送多个请求，这些请求的头部相似或者完全一样，协议就会消除这些重复的部分</li><li>多路复用：HTTP2可以并发多个请求和响应，不用按顺序对请求进行响应，避免了对头堵塞的问题</li><li>二进制格式：在HTTP2中数据不再是纯文本的格式，而全面是用二进制编码，报文首部变为头信息帧，报文主体变为数据帧，这样增加了数据传输的效率</li></ul><h3 id="HTTP3对HTTP2的改进"><a href="#HTTP3对HTTP2的改进" class="headerlink" title="HTTP3对HTTP2的改进"></a>HTTP3对HTTP2的改进</h3><p>HTTP2中多个请求复用一个TCP连接，底层TCP协议并不清楚有多少个请求，一旦发生丢包问题，就会触发TCP的重传机制，这样一个TCP连接中的所有HTTP请求都会等待这个被丢的包重传回来，因此HTTP3将下层的TCP协议变为了UDP协议</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/08/11/hello-world/"/>
    <url>/2022/08/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
